---
title: MySQL性能优化 -- 数据库锁
tags: 
    - mysql
categories: 
    - mysql
---

### 引言

mysql对于锁的使用，和大多数锁的定义一样（S锁和X锁），一方面在于保证数据的一致和完整性，另一方面用户保证数据在并发读写的场景下的有序性，一个高效的锁模型直接影响访问的性能

### 锁

锁在不用语言、组件的实现中，主要遵循两种标准：**读锁**（或者称为共享锁、S锁）、**写锁**（或者称为排他锁、X锁），读锁**特点是可以对同一个资源加多个读锁，且有读锁存在的时候，写锁是阻塞的**，而写锁的主要特点是，**当某个线程访问资源开启了一个写锁，这个资源不允许添加任何其他的锁**

### MySQL的锁的原理

mysql中，不同的存储引擎对锁的实现是有差异的，这里以InnoDB和MyISAM为例，mysql实现了3种类型的锁定机制：**行级锁**、**表级锁**、**页锁**，每个级别的锁主要在于粒度上的区别，下面来分析一下各个锁的区别

#### 表级锁

表级锁，顾名思义，就是锁的粒度是以整张表为基础的，粒度在整个mysql的锁中最大，因为粒度大，所以整个表锁的实现相当简单，资源的消耗最小，获取和释放锁的速度很快，但相对的带来的弊端就是，在高并发的场景下，非常容易出现竞争，所以性能表现的很差。

表锁的实现在内部分为读锁定和写锁定，主要通过4个队列来实现这两种的锁定

```shell
current read-lock queue   // 当前读锁队列
pending read-lock queue   // 等待读锁队列
current wirte-lock queue  // 当前写锁队列
pending write-lock queue  // 等待写锁队列
```

4个队列按照时间顺序存放锁的信息

##### 读锁定

当申请获取资源的读锁定时需要满足两个条件：

1. 当前申请的资源没有一个写锁定
2. 当前申请的资源对应的`pending write-lock queue`没有一个等待写锁定的请求

满足条件后，会立即在`current read-lock queue`中存入一个读锁定的信息，反之则进入`pending read-lock queue`

##### 写锁定

当申请获取资源的读锁定时，会先判断`current wirte-lock queue`是否存在值，如果不存在，则直接写入`current wirte-lock queue`，否在再判断`pending write-lock queue`，如果则写入此队列，否则继续判断`current read-lock queue`与`pending read-lock queue`，原理逻辑同上。*这里与S锁和X锁的规范实现原理一致*

#### 行级锁

行级锁最大的特点就是锁定的颗粒度很小，由于锁定的资源最小，所以发生竞争的概率也最小，能过给与程序最大的能力处理并发的场景，提供应用系统的整体性能。MyISAM引擎不支持该锁。

行级锁主要由存储引擎自己实现，InnoDB的实现也是基于共享锁和排他锁的原理，为了让共享锁和排他锁共存，InnoDB实现了另外两种类型的锁：意向共享锁、意向排他锁。意向锁的主要作用是，当事物访问一个资源的时候，如果该资源（行记录）存在一个排他锁，这时候可以对该表加一个意向锁。所以，InnoDB对锁的类型总共可以绯闻4种类型的锁：

* 共享锁（S）
* 排他锁（X）
* 意向共享锁（IS）
* 意向排他锁（IX）

MySQL在**Repeatable Read**隔离级别下，通过使用间隙锁+行锁的方式（Next-key lock）来防止幻读，对于间隙锁，是指对一段范围内的数据加锁，即使这个数据不存在，间隙锁的实现是基于当前记录对应的第一个索引键之前和最后一个索引键之后的区域，例如：

| id   | name | age  |
| ---- | ---- | ---- |
| 1    | T2   | 1    |
| 2    | T3   | 2    |
| 5    | T6   | 5    |
| 9    | T9   | 9    |
| 10   | T10  | 10   |

```mysql
select * from t_user where age = 5 for update
```

如果事务A对上述表执行如下sql，此时会存在一个`(2, 9]`的间隙锁，事务B如果想在范围内做新增，修改，删除，加锁等操作，都将阻塞，例如

```mysql
insert into t_user (name, age) values ('T3', 3);
insert into t_user (name, age) values ('T6', 6);
```

如果where后面是一个主键、或者是一个唯一索引，那么将不会开启这个间隙锁，间隙锁唯一的作用就是防止其他事务的插入引起的幻读问题

#### 页锁

页锁是mysql中一种特殊的锁，介于行锁和表锁之间，暂不讨论。

### 锁的优化

