---
title: Redis使用的几点建议
tags: 
    - redis
    - NoSQL
    - 缓存
categories:
    - redis

---

最近产线出现一个事故，导致核心支付服务不可用将近6个小时🙄️🙄️🙄️，最终排查下来发现是redis使用不当照成，故对redis使用姿势作一定的总结和建议

### 事故的前世今生

早上10点接到电话，所有门店支付失败，支付服务不可用，直接现象出现Gateway504错误，查看支付服务日志，发现出现大量的redis客户端oom错误（redis客户端使用的是lettuce），dump内存后，发现内存中存在1.3个G的交易流水的json字符串，通过字符串的单号，查库发现，一笔交易多达8万多次操作流水，确认后发现，有个定时任务死循环在调用支付服务，支付服务接受请求后，会将此订单下所有的交易流水推送到redis，lettuce是基于netty的，netty传输中发现传输字符大小 > 网络自负缓冲区大小，故触发内存的申请，然而。。。数据大传输慢，而客户端还在源源不断的请求。内存直接爆炸（让运维协助调整10g内存，5分钟就被吃爆）

### redis基础

在了解redis改如何使用之前，先来简单的了解一下redis的基本特性

* k-v存储的缓存NoSQL数据库
* 数据结构支持：String、List、Set、Map等
* 支持channel发布订阅
* 服务端单线程传输，服务器网络模型基于多路复用的epoll模型
* 支持持久化：snapshot、append-only-file
* 支持事物
* 部署模型支持单机、主从、集群

### redis使用建议

* 不同场景的redis服务，请做好隔离
  在不同业务的场景下，最好不要使用同一个redis服务，这也能避免单点故障

* 根据业务需求来确定是否打开持久化
  redis本身提供两种持久化方式，数据要做持久化，势必会损失性能，如果是单纯的数据缓存，如果丢了，重新回源到db，在刷到缓存中就能解决的，就不要打开持久化（比如说用户的某些配置信息、用户的基本信息等），如果是数据重要性和一致性要求苛刻的，那么就一定要开启持久化（比如为了高并发，将请求订单先入缓存的场景）

* redis的key和value的设计不能过大
  redis因为是单线程的工作方式，虽然服务端的IO模型是基于epoll的事件驱动的方式来完成，但是仍然会因为value值过大导致的传输效率过慢影响其他的请求的性能，例如，A、B（Big-Value）、C三个请求到达redis服务端后，当redis开始传输B的数据时，由于value太大，导致A、C都将处于等待状态，所以这里可以根据B的业务场景，将B的value拆分成多个小的k-v

* 缓存失效时间
  缓存很多小伙伴使用的时候，都未设置缓存的失效时间，这意味着缓存是永久有效的，在并发写缓存的场景下，缓存数据很容易和db里的数据造成不一致状态。缓存必须根据业务的需求，制定失效的处理，失效需要警惕雪崩的风险，如果是用户线程上的缓存，那么最好对缓存的失效时间加一些范围波动以防雪崩

* 减小连接次数
  redis毕竟是外部资源，所有的请求都需要走网络，网络的通信势必会涉及到打开关闭连接，处理socket回话，数据序列化与反序列化等相对耗时操作，所以，当业务场景中存在多次读缓存的场景，可以考虑使用pipeline方式，一次批处理所有请求，这样的服务性能提升是巨大的

* 慎用事物
  无论在什么存储中，保证事物的ACID都不是一件轻松简单的事儿，保证ACID的代价就是性能的损耗，而使用缓存的目的就是为了提升性能，如果不到万不得已的强一致性场景下，就不要使用事物！

* 缓存更新策略
  缓存的更新是个大问题，更新数据库和更新缓存，这两步动作，没有在一个事物中，所以很难保证一直性，对于缓存更新，一般使用下面几种策略：

  ##### 先更新数据库，再更新缓存

  此方法适用数据更新频次慢（一周、一月更新一次），访问频次高的静态数据，如果因为网络原因更新缓存失败，那么需要异步补偿更新

  ##### 先更新数据库，再删除缓存

  此方法适合大多数场景，但在并发场景仍然无法保证一直性，例如：缓存中Null，B查询数据库老值，A更新数据库，A删除缓存，B更新老值到缓存。对于删除失败依旧需要外部资源保证补偿